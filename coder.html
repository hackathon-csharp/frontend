<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>IR LED Color Encoder</title>
<style>
body{font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;margin:16px;background:#f6f7fb;color:#0b1220}
h1{font-size:20px;margin:0 0 8px}
.box{padding:12px;background:#fff;border-radius:10px;box-shadow:0 2px 8px rgba(12,20,40,0.06);margin-bottom:12px}
canvas{background:#000;border-radius:8px;display:block;margin-top:8px}
button{padding:8px 12px;border-radius:8px;border:0;background:#2563eb;color:#fff;cursor:pointer;margin-top:8px;margin-right:8px}
input[type=text]{width:100%;padding:6px;border-radius:6px;border:1px solid #ccc;margin-top:4px}
#signalLog{margin-top:8px;max-height:200px;overflow:auto;background:#f0f4ff;color:#0b1220;padding:8px;border-radius:8px;font-family:monospace;font-size:13px}
</style>
</head>
<body>
<h1>IR LED Color Encoder</h1>

<div class="box">
  <label>Введите сообщение для передачи:</label>
  <input type="text" id="messageInput" placeholder="Введите текст">
  <label for="unitDurationInput">Длительность единицы (мс):</label>
  <input type="number" id="unitDurationInput" min="50" step="10" value="600">
  <button id="startBtn">Начать отправку</button>
  <button id="syncBtn">Запустить синхронизацию</button>
</div>

<div class="box">
  <canvas id="ledCanvas" width="200" height="200"></canvas>
  <div id="signalLog">—</div>
</div>

<script src="datapacklib.js"></script>
<script>
const canvas = document.getElementById('ledCanvas');
const ctx = canvas.getContext('2d');
const startBtn = document.getElementById('startBtn');
const syncBtn = document.getElementById('syncBtn');
const messageInput = document.getElementById('messageInput');
const unitDurationInput = document.getElementById('unitDurationInput');
const signalLogEl = document.getElementById('signalLog');

const { LightLevel } = datapack;
const textEncoder = new TextEncoder();

const DEFAULT_UNIT_DURATION = 600;
const MIN_DURATION_FRACTION = 0.2;
const MAX_LOG_ENTRIES = 300;

let currentUnitDuration = DEFAULT_UNIT_DURATION;
let sending = false;
let stopRequested = false;
let syncActive = false;

const colorMap = {
  [LightLevel.Red]: 'rgb(255,0,0)',
  [LightLevel.Green]: 'rgb(0,255,0)',
  [LightLevel.Blue]: 'rgb(0,0,255)',
  [LightLevel.White]: 'rgb(255,255,255)',
  [LightLevel.Off]: 'rgb(0,0,0)'
};

const colorNames = {
  [LightLevel.Red]: 'Красный',
  [LightLevel.Green]: 'Зелёный',
  [LightLevel.Blue]: 'Синий',
  [LightLevel.White]: 'Белый',
  [LightLevel.Off]: 'Выкл'
};

function appendLog(text) {
  if (typeof text !== 'string' || !text.length) {
    return;
  }
  if (signalLogEl.textContent.trim() === '—') {
    signalLogEl.textContent = '';
  }
  const entry = document.createElement('div');
  entry.textContent = text;
  signalLogEl.appendChild(entry);
  while (signalLogEl.childNodes.length > MAX_LOG_ENTRIES) {
    signalLogEl.removeChild(signalLogEl.firstChild);
  }
  signalLogEl.scrollTop = signalLogEl.scrollHeight;
}

function sanitizeUnitDuration(value) {
  const numeric = Number(value);
  if (!Number.isFinite(numeric) || numeric <= 0) {
    return DEFAULT_UNIT_DURATION;
  }
  return Math.min(10000, Math.max(50, Math.round(numeric)));
}

function updateUnitDuration() {
  const sanitized = sanitizeUnitDuration(unitDurationInput.value);
  currentUnitDuration = sanitized;
  unitDurationInput.value = sanitized;
  datapack.setSignalDuration(sanitized);
  datapack.setMinDuration(Math.max(30, Math.round(sanitized * MIN_DURATION_FRACTION)));
}

function drawColor(level) {
  ctx.fillStyle = colorMap[level] || colorMap[LightLevel.Off];
  ctx.fillRect(0, 0, canvas.width, canvas.height);
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function transmitLoop(message) {
  sending = true;
  stopRequested = false;
  startBtn.textContent = 'Остановить';
  startBtn.disabled = false;
  syncBtn.disabled = true;
  signalLogEl.textContent = '';
  drawColor(LightLevel.Off);

  updateUnitDuration();

  let payload;
  let commands;
  try {
    datapack.resetEncoder();
    payload = textEncoder.encode(message);
    datapack.setSendData(payload, payload.length);
    commands = datapack.getSendCommands();
  } catch (error) {
    appendLog('Ошибка кодирования: ' + (error && error.message ? error.message : error));
    drawColor(LightLevel.Off);
    startBtn.textContent = 'Начать отправку';
    syncBtn.disabled = false;
    sending = false;
    stopRequested = false;
    return;
  }

  if (!Array.isArray(commands) || !commands.length) {
    appendLog('Не удалось сформировать команды для передачи');
    drawColor(LightLevel.Off);
    startBtn.textContent = 'Начать отправку';
    syncBtn.disabled = false;
    sending = false;
    stopRequested = false;
    return;
  }

  const hexDump = Array.from(payload).map(b => b.toString(16).padStart(2, '0')).join(' ');
  appendLog(`Сообщение: "${message}" (${payload.length} байт)`);
  appendLog(`HEX: ${hexDump}`);
  appendLog(`Команд в цикле: ${commands.length}`);

  let iteration = 0;
  while (!stopRequested) {
    iteration += 1;
    appendLog(`— Цикл ${iteration} —`);

    for (const command of commands) {
      if (stopRequested) {
        break;
      }
      const level = command.value;
      const durationMs = Math.max(1, Math.round(command.duration));
      drawColor(level);
      appendLog(`${colorNames[level] || `Уровень ${level}`}: ${durationMs} мс`);
      await sleep(durationMs);
    }

    drawColor(LightLevel.Off);
    if (!stopRequested) {
      await sleep(Math.max(1, Math.round(currentUnitDuration)));
    }
  }

  appendLog('Передача остановлена');
  drawColor(LightLevel.Off);
  startBtn.textContent = 'Начать отправку';
  syncBtn.disabled = false;
  sending = false;
  stopRequested = false;
}

async function runSyncSequence() {
  if (sending || syncActive) {
    return;
  }
  syncActive = true;
  syncBtn.disabled = true;
  startBtn.disabled = true;
  signalLogEl.textContent = '';

  const sequence = [
    { level: LightLevel.Off, name: 'Выкл', time: 1500 },
    { level: LightLevel.White, name: 'Белый', time: 1500 },
    { level: LightLevel.Off, name: 'Выкл', time: 800 },
    { level: LightLevel.Red, name: 'Красный', time: 1500 },
    { level: LightLevel.Off, name: 'Выкл', time: 800 },
    { level: LightLevel.Green, name: 'Зелёный', time: 1500 },
    { level: LightLevel.Off, name: 'Выкл', time: 800 },
    { level: LightLevel.Blue, name: 'Синий', time: 1500 },
    { level: LightLevel.Off, name: 'Выкл', time: 1500 }
  ];

  try {
    appendLog('Синхронизация начата');
    for (const step of sequence) {
      drawColor(step.level);
      appendLog(`${step.name}: ${step.time} мс`);
      await sleep(step.time);
    }
    appendLog('Синхронизация завершена');
  } finally {
    drawColor(LightLevel.Off);
    syncActive = false;
    syncBtn.disabled = false;
    startBtn.disabled = false;
  }
}

unitDurationInput.addEventListener('change', updateUnitDuration);
unitDurationInput.addEventListener('blur', updateUnitDuration);
unitDurationInput.addEventListener('keyup', event => {
  if (event.key === 'Enter') {
    updateUnitDuration();
  }
});

startBtn.addEventListener('click', () => {
  if (syncActive) {
    alert('Подождите завершения синхронизации');
    return;
  }
  if (sending) {
    stopRequested = true;
    appendLog('Ожидание завершения текущего цикла...');
    return;
  }

  const message = messageInput.value.trim();
  if (!message.length) {
    alert('Введите сообщение!');
    return;
  }

  transmitLoop(message);
});

syncBtn.addEventListener('click', () => {
  runSyncSequence();
});

updateUnitDuration();
drawColor(LightLevel.Off);
</script>
</body>
</html>
