<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>IR LED Color Decoder</title>
<style>
body{font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;margin:16px;background:#f6f7fb;color:#0b1220}
h1{font-size:20px;margin:0 0 8px}
.row{display:flex;gap:12px;align-items:flex-start;flex-wrap:wrap}
video, canvas{background:#000;border-radius:8px;max-width:100%;}
#video{display: none;}
#controls{margin-top:12px;display:flex;gap:8px;flex-wrap:wrap}
label{font-size:13px}
.box{padding:12px;background:#fff;border-radius:10px;box-shadow:0 2px 8px rgba(12,20,40,0.06)}
input[type=range]{width:180px}
#log{height:140px;overflow:auto;background:#0b1220;color:#dff3ff;padding:8px;border-radius:8px;font-family:monospace;font-size:13px}
#decoded{height:140px;overflow:auto;background:#f0f4ff;color:#0b1220;padding:8px;border-radius:8px;font-family:monospace;font-size:13px;margin-top:8px}
button{padding:8px 12px;border-radius:8px;border:0;background:#2563eb;color:#fff;cursor:pointer}
button.secondary{background:#e6eefc;color:#0b1220}
small{color:#39424a}
</style>
</head>
<body>
<h1>IR LED Color Decoder</h1>
<div class="row">
  <div class="box" style="flex:1;min-width:320px">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="overlay" width="640" height="480" style="position:relative;display:block;margin-top:8px"></canvas>
    <div id="controls">
      <button id="startTransmissionBtn">Начать запись</button>
      <button id="syncBtn" class="secondary">Синхронизация</button>
    </div>
    <p style="margin-top:6px"><small>Кликните на видео, чтобы выбрать область (ROI) для слежения. По умолчанию отслеживается центр.</small></p>
  </div>
  <div class="box" style="width:360px">
    <h2 style="margin-top:0">Информация</h2>
    <p style="margin:6px 0">Датчик фиксирует цвет светодиода и длительность его состояния.</p>
    <h3 style="margin-bottom:6px">Состояния</h3>
    <div id="status">—</div>
    <h3 style="margin-bottom:6px">Записанные события</h3>
    <div id="log"></div>
    <h3 style="margin-bottom:6px">Декодированное сообщение</h3>
    <div id="decoded">—</div>
  </div>
</div>

<script src="datapacklib.js"></script>
<script>
const video = document.getElementById('video');
const overlay = document.getElementById('overlay');
const ctx = overlay.getContext('2d');
const startTransmissionBtn = document.getElementById('startTransmissionBtn');
const syncBtn = document.getElementById('syncBtn');
const statusEl = document.getElementById('status');
const logEl = document.getElementById('log');
const decodedEl = document.getElementById('decoded');

let stream = null;
let running = false;
let rafId = null;
let roi = null;

let transmissionActive = false;
let blinkEvents = [];
let lastTransitionTime = Date.now();
let lastColor = datapack.LightLevel.Off;

let minBrightness = Infinity;
let maxBrightness = -Infinity;
let calibratedThreshold = null;
let syncing = false;

async function startCamera() {
  if (running) return;
  try {
    stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:"environment", width:1280, height:720 }, audio:false });
  } catch(err) { statusEl.textContent = 'Ошибка доступа к камере: ' + (err.message||err.name); return; }
  video.srcObject = stream;
  video.muted = true; video.playsInline = true; video.autoplay = true;
  try { await video.play(); } catch(e){}
  overlay.width = video.videoWidth || 640;
  overlay.height = video.videoHeight || 480;
  if (!roi) roi = { x: overlay.width/2, y: overlay.height/2, size:64 };
  running = true;
  statusEl.textContent = 'Камера запущена';
  loop();
}

function log(msg){
  const time = new Date().toLocaleTimeString();
  logEl.innerHTML = `<div>[${time}] ${msg}</div>` + logEl.innerHTML;
  const lines = logEl.querySelectorAll('div');
  if(lines.length>200) lines[lines.length-1].remove();
}

overlay.addEventListener('click',(e)=>{
  const rect = overlay.getBoundingClientRect();
  const x = Math.floor((e.clientX-rect.left)*(overlay.width/rect.width));
  const y = Math.floor((e.clientY-rect.top)*(overlay.height/rect.height));
  roi = { x, y, size:64 };
  log('ROI установлен: x=' + roi.x + ', y=' + roi.y);
});

function detectColor(imageData){
  const data = imageData.data;
  let r=0, g=0, b=0;
  const px = imageData.width * imageData.height;
  for(let i=0; i<data.length; i+=4){
    r += data[i];
    g += data[i+1];
    b += data[i+2];
  }
  r = Math.round(r/px);
  g = Math.round(g/px);
  b = Math.round(b/px);

  let level = datapack.LightLevel.Off;
  const threshold = 200;

  const rHigh = r > threshold;
  const gHigh = g > threshold;
  const bHigh = b > threshold;

  const highCount = [rHigh, gHigh, bHigh].filter(Boolean).length;

  if(highCount === 0){
    level = datapack.LightLevel.Off;
  } else if(highCount === 3){
    level = datapack.LightLevel.White;
  } else if(highCount === 1){
    if(rHigh) level = datapack.LightLevel.Red;
    if(gHigh) level = datapack.LightLevel.Green;
    if(bHigh) level = datapack.LightLevel.Blue;
  } else if(highCount === 2){
    // берем максимальный канал
    if(r >= g && r >= b) level = datapack.LightLevel.Red;
    else if(g >= r && g >= b) level = datapack.LightLevel.Green;
    else level = datapack.LightLevel.Blue;
  }

  return { level, rgb: { r, g, b } };
}


function loop(){
  if(!running) return;
  function frame(){
    rafId = requestAnimationFrame(frame);
    ctx.drawImage(video,0,0,overlay.width,overlay.height);

    const s = roi.size;
    const rx = roi.x - s/2;
    const ry = roi.y - s/2;
    ctx.strokeStyle='lime'; ctx.lineWidth=2;
    ctx.strokeRect(rx,ry,s,s);

    try{
      const img = ctx.getImageData(rx,ry,s,s);
      const result = detectColor(img);
      const color = result.level;
      const rgb = result.rgb;
      statusEl.textContent = ['Выкл','Белый','Красный','Зелёный','Синий'][color] +
                             ` (R:${rgb.r} G:${rgb.g} B:${rgb.b})`;

      if(!transmissionActive) return;

      if(color !== lastColor){
        const now = Date.now();
        const durationSec = (now - lastTransitionTime)/1000;
        blinkEvents.push({ level:lastColor, duration:durationSec });
        lastTransitionTime = now;
        lastColor = color;
        log(`Светодиод: ${['Выкл','Белый','Красный','Зелёный','Синий'][color]}, длительность предыдущего состояния: ${durationSec.toFixed(2)} сек`);
        decodeBlinkEvents();
      }
    } catch(e){ console.warn('getImageData error',e); }
  }
  frame();
}

function startSync() {
  if (syncing) return;
  syncing = true;
  log('Синхронизация: измеряем минимум (5 сек)...');
  minBrightness = Infinity; maxBrightness = -Infinity;
  let phase=0; let phaseTime=Date.now();
  function syncStep(){
    const now=Date.now(); const elapsed=(now-phaseTime)/1000;
    if(phase===0){
      if(roi){
        const img=ctx.getImageData(roi.x-roi.size/2,roi.y-roi.size/2,roi.size,roi.size);
        let sum=0; const data=img.data;
        for(let i=0;i<data.length;i+=4) sum+=data[i];
        const avg=sum/(roi.size*roi.size);
        if(avg<minBrightness) minBrightness=avg;
      }
      if(elapsed>=5){ phase=1; phaseTime=now; log('Теперь включите светодиод. Измеряем максимум (5 сек)...'); }
    } else if(phase===1){
      if(roi){
        const img=ctx.getImageData(roi.x-roi.size/2,roi.y-roi.size/2,roi.size,roi.size);
        let sum=0; const data=img.data;
        for(let i=0;i<data.length;i+=4) sum+=data[i];
        const avg=sum/(roi.size*roi.size);
        if(avg>maxBrightness) maxBrightness=avg;
      }
      if(elapsed>=5){
        calibratedThreshold=(minBrightness+maxBrightness)/2;
        log(`Синхронизация завершена. minB=${minBrightness.toFixed(1)}, maxB=${maxBrightness.toFixed(1)}, порог=${calibratedThreshold.toFixed(1)}`);
        syncing=false; return;
      }
    }
    requestAnimationFrame(syncStep);
  }
  syncStep();
}

const decoder = new datapack.Decoder((payload,length)=>{
  const text=new TextDecoder().decode(payload);
  decodedEl.textContent=text;
  log('Сообщение декодировано: '+text);
});

function decodeBlinkEvents(){
  const buf = new datapack.SignalBuffer();
  blinkEvents.forEach(ev=>buf.push(ev));
  buf.forEach(change=>decoder.feed(change));
}

startCamera();

startTransmissionBtn.addEventListener('click',()=>{
  transmissionActive=true;
  blinkEvents=[];
  lastTransitionTime=Date.now();
  lastColor=datapack.LightLevel.Off;
  log('Начата запись сигналов');
});
syncBtn.addEventListener('click', startSync);

window.addEventListener('beforeunload',()=>{ if(stream) stream.getTracks().forEach(t=>t.stop()); });
</script>
</body>
</html>
