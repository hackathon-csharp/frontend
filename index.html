<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>IR Light Decoder</title>
  <style>
    :root {
      color-scheme: light dark;
    }
    body {
      margin: 0;
      font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
      background: #0f172a;
      color: #e2e8f0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 24px 16px 48px;
      box-sizing: border-box;
    }
    h1 {
      margin: 0 0 24px;
      font-size: clamp(22px, 4vw, 32px);
      font-weight: 600;
      text-align: center;
    }
    main {
      display: grid;
      gap: 20px;
      width: min(1100px, 100%);
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    }
    .panel {
      background: rgba(15, 23, 42, 0.66);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 24px 48px -20px rgba(15, 23, 42, 0.8);
      backdrop-filter: blur(6px);
    }
    #video {
      width: 100%;
      border-radius: 12px;
      background: #000;
      display: none;
    }
    canvas {
      width: 100%;
      max-height: 420px;
      border-radius: 12px;
      margin-top: 12px;
      background: #000;
    }
    #status {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 12px;
    }
    #currentColorBox {
      width: 32px;
      height: 32px;
      border-radius: 8px;
      border: 1px solid rgba(235, 245, 255, 0.4);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      margin-right: 12px;
      font-size: 12px;
      font-weight: 600;
    }
    .label {
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: rgba(148, 163, 184, 0.9);
      margin: 16px 0 6px;
    }
    .data-box {
      background: rgba(15, 23, 42, 0.75);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 12px;
      padding: 12px;
      min-height: 82px;
      font-family: "JetBrains Mono", "SFMono-Regular", Consolas, monospace;
      font-size: 13px;
      overflow: auto;
      white-space: pre-wrap;
      word-break: break-word;
    }
    #log {
      max-height: 200px;
    }
    small {
      color: rgba(148, 163, 184, 0.9);
    }
    a, a:visited {
      color: #60a5fa;
      text-decoration: none;
    }
    .status-ok {
      color: #4ade80;
    }
    .status-warn {
      color: #facc15;
    }
    .status-error {
      color: #f87171;
    }
  </style>
</head>
<body>
  <h1>Оптический декодер • Камера → datapack</h1>
  <main>
    <section class="panel" id="capturePanel">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="overlay" width="640" height="480"></canvas>
      <p><small>Нажмите по кадру, чтобы выбрать область анализа (ROI). По умолчанию отслеживается центр рамки.</small></p>
    </section>
    <section class="panel" id="infoPanel">
      <div id="status" class="status-warn">Инициализация…</div>
      <div class="label">Текущий цвет</div>
      <div style="display:flex; align-items:center; gap:12px;">
        <div id="currentColorBox">—</div>
        <div id="currentColor">—</div>
      </div>
      <div class="label">Декодированное сообщение</div>
      <div id="decoded" class="data-box">—</div>
      <div class="label">HEX буфер (как в example_js.js)</div>
      <div id="buffer" class="data-box">—</div>
      <div class="label">Журнал событий</div>
      <div id="log" class="data-box"></div>
    </section>
  </main>

  <script src="datapacklib.js"></script>
  <script>
    const video = document.getElementById('video');
    const overlay = document.getElementById('overlay');
    const ctx = overlay.getContext('2d');

    const statusEl = document.getElementById('status');
    const currentColorEl = document.getElementById('currentColor');
    const currentColorBox = document.getElementById('currentColorBox');
    const bufferEl = document.getElementById('buffer');
    const decodedEl = document.getElementById('decoded');
    const logEl = document.getElementById('log');

    const { LightLevel } = datapack;

    const fromColorToLevel = {
      off: LightLevel.Off,
      red: LightLevel.Red,
      green: LightLevel.Green,
      blue: LightLevel.Blue,
      white: LightLevel.White,
    };

    const colorNames = {
      [LightLevel.Off]: 'Выкл',
      [LightLevel.Red]: 'Красный',
      [LightLevel.Green]: 'Зелёный',
      [LightLevel.Blue]: 'Синий',
      [LightLevel.White]: 'Белый',
    };

  const DEFAULT_UNIT_DURATION_MS = 600;
  const MIN_EVENT_DURATION_FLOOR = 30;
  const MAX_OBSERVED_DURATIONS = 48;
  const MAX_SAMPLED_DURATION_MS = 2500;
    const ROI_DEFAULT_SIZE = 160;

    let lastColor = 'off';
  let lastChange = performance.now();
  let lastEventTimestamp = performance.now();
    let pendingOffDecode = false;
    let roi = null;

  let lastBufferHex = '';
  let lastDecodedText = '';

  let estimatedUnitMs = DEFAULT_UNIT_DURATION_MS;
  let minEventDurationMs = 90;
  let offDecodeDelayMs = DEFAULT_UNIT_DURATION_MS * 1.6;
  let inactivityResetMs = 30000;
  const observedDurations = [];
  let lastTimingAnnouncement = 0;

    const textDecoder = new TextDecoder();

  datapack.resetDecoder();
  datapack.setSignalDuration(DEFAULT_UNIT_DURATION_MS);
  datapack.setMinDuration(minEventDurationMs);

    datapack.setOnPacketReceived((pkg) => {
      log(`Пакет принят (${pkg.length} байт)`);
    });

    function log(message, level = 'info') {
      const time = new Date().toLocaleTimeString();
      const line = document.createElement('div');
      line.textContent = `[${time}] ${message}`;
      if (level === 'error') line.style.color = '#fca5a5';
      if (level === 'warn') line.style.color = '#fde68a';
      logEl.prepend(line);
      while (logEl.children.length > 200) {
        logEl.removeChild(logEl.lastChild);
      }
    }

    function setStatus(message, tone = 'warn') {
      const suffix = Number.isFinite(estimatedUnitMs) ? ` · ≈${Math.round(estimatedUnitMs)} мс` : '';
      statusEl.textContent = `${message}${suffix}`;
      switch (tone) {
        case 'ok':
          statusEl.className = 'status-ok';
          break;
        case 'error':
          statusEl.className = 'status-error';
          break;
        default:
          statusEl.className = 'status-warn';
          break;
      }
    }

    function recomputeTiming() {
      if (!observedDurations.length) {
        return;
      }

      const sorted = observedDurations.slice().sort((a, b) => a - b);
      const median = sorted[Math.floor(sorted.length / 2)];

      if (!Number.isFinite(median) || median <= 0) {
        return;
      }

      const newUnit = Math.max(50, Math.min(1500, median));
      const newMin = Math.max(MIN_EVENT_DURATION_FLOOR, Math.round(newUnit * 0.35));
      const decoderMin = Math.max(20, Math.round(newUnit * 0.25));
      const newOffDelay = Math.max(newUnit * 1.3, decoderMin * 3);
      const newInactivity = Math.max(newUnit * 40, 8000);

      const changed =
        Math.abs(newUnit - estimatedUnitMs) > 6 ||
        Math.abs(newMin - minEventDurationMs) > 6 ||
        Math.abs(newOffDelay - offDecodeDelayMs) > 30;

      estimatedUnitMs = newUnit;
      minEventDurationMs = newMin;
      offDecodeDelayMs = newOffDelay;
      inactivityResetMs = newInactivity;
      datapack.setMinDuration(decoderMin);

      if (changed) {
        const now = performance.now();
        if (now - lastTimingAnnouncement > 2500) {
          log(`Адаптация таймингов: unit≈${Math.round(newUnit)} мс, порог≥${minEventDurationMs} мс`, 'warn');
          lastTimingAnnouncement = now;
        }
      }
    }

    function observeDuration(durationMs) {
      if (!Number.isFinite(durationMs) || durationMs <= 0 || durationMs > MAX_SAMPLED_DURATION_MS) {
        return;
      }
      observedDurations.push(durationMs);
      if (observedDurations.length > MAX_OBSERVED_DURATIONS) {
        observedDurations.shift();
      }
      recomputeTiming();
    }

    function resetDecoderState(reason) {
      datapack.resetDecoder();
      lastBufferHex = '';
      lastDecodedText = '';
      bufferEl.textContent = '—';
      decodedEl.textContent = '—';
      lastChange = performance.now();
      lastEventTimestamp = performance.now();
      if (reason) {
        log(reason, 'warn');
      }
      setStatus('Ожидание сигнала');
    }

    function getTrimmedPayload() {
      const data = datapack.getReceivedData();
      if (!(data instanceof Uint8Array) || data.length === 0) {
        return null;
      }

      let start = 0;
      while (start < data.length && data[start] === 0) {
        start += 1;
      }
      if (start >= data.length) {
        return null;
      }

      let end = start;
      while (end < data.length && data[end] !== 0) {
        end += 1;
      }
      if (end < data.length && data[end] === 0) {
        end += 1; // include first zero terminator
      }

      const payload = data.subarray(start, end);
      const hex = Array.from(payload, (b) => b.toString(16).padStart(2, '0')).join(' ');
      let text = '';
      try {
        text = textDecoder.decode(payload);
      } catch (err) {
        text = '';
      }
      return { payload, hex, text };
    }

    function updateBuffer() {
      const result = getTrimmedPayload();
      if (!result) {
        if (lastBufferHex !== '') {
          bufferEl.textContent = '—';
          lastBufferHex = '';
        }
        return null;
      }
      if (result.hex !== lastBufferHex) {
        bufferEl.textContent = result.hex || '—';
        lastBufferHex = result.hex;
      }
      return result;
    }

    function attemptDecode(forceLog = false, cachedResult = null) {
      const result = cachedResult || getTrimmedPayload();
      if (!result) {
        if (forceLog) {
          log('Пакет не распознан', 'error');
          setStatus('Пакет не распознан', 'error');
        }
        return;
      }

      const hasText = typeof result.text === 'string' && result.text.length > 0;
      if (hasText && result.text !== lastDecodedText) {
        decodedEl.textContent = result.text;
        setStatus('Сообщение получено', 'ok');
        log(`Раскодированное сообщение (${result.payload.length} байт): "${result.text}"`);
        log(`HEX: ${result.hex}`);
        lastDecodedText = result.text;
      } else if (forceLog && !hasText) {
        log('Пакет не распознан', 'error');
        setStatus('Пакет не распознан', 'error');
      }
    }

    function recordEvent(level, durationMs) {
      const normalizedDuration = Math.max(minEventDurationMs, Math.round(durationMs));
      try {
        datapack.feed({ value: level, duration: normalizedDuration });
      } catch (error) {
        log(`Ошибка feed: ${error && error.message ? error.message : error}`, 'error');
        return;
      }
      lastEventTimestamp = performance.now();
      const label = colorNames[level] || `Level ${level}`;
      log(`Событие: ${label} (${normalizedDuration} мс)`);
      if (level !== LightLevel.Off || normalizedDuration < estimatedUnitMs * 2.5) {
        observeDuration(normalizedDuration);
      }
      const payload = updateBuffer();
      if (level === LightLevel.Off) {
        attemptDecode(true, payload);
      }
    }

    function detectColor(imageData) {
      const data = imageData.data;
      let sumR = 0, sumG = 0, sumB = 0;
      let brightCount = 0;

      for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const brightness = (r + g + b) / 3;
        if (brightness < 35) continue;
        sumR += r;
        sumG += g;
        sumB += b;
        brightCount += 1;
      }

      if (!brightCount) {
        return { dominant: 'off', r: 0, g: 0, b: 0, brightness: 0 };
      }

      const avgR = sumR / brightCount;
      const avgG = sumG / brightCount;
      const avgB = sumB / brightCount;
      const brightness = (avgR + avgG + avgB) / 3;
      const total = avgR + avgG + avgB;

      if (!Number.isFinite(total) || total <= 0) {
        return { dominant: 'off', r: 0, g: 0, b: 0, brightness: 0 };
      }

      const ratios = [
        { name: 'red', value: avgR },
        { name: 'green', value: avgG },
        { name: 'blue', value: avgB }
      ].sort((a, b) => b.value - a.value);

      const top = ratios[0];
      const mid = ratios[1];
      const spread = Math.max(avgR, avgG, avgB) - Math.min(avgR, avgG, avgB);
      const whiteness = Math.max(
        Math.abs(avgR - avgG),
        Math.abs(avgR - avgB),
        Math.abs(avgG - avgB)
      );

      let dominant = 'off';

      if (brightness >= 55 && top.value >= 70) {
        const ratioGap = top.value - mid.value;
        if (spread < 25 && brightness > 90) {
          dominant = 'white';
        } else if (whiteness < 18 && brightness > 100 && mid.value > 80) {
          dominant = 'white';
        } else if (ratioGap >= 25) {
          dominant = top.name;
        }
      }

      if (dominant === 'off' && brightness > 110 && whiteness < 15) {
        dominant = 'white';
      }

      return {
        dominant,
        r: Math.round(avgR),
        g: Math.round(avgG),
        b: Math.round(avgB),
        brightness: Math.round(brightness)
      };
    }

    overlay.addEventListener('click', (event) => {
      const rect = overlay.getBoundingClientRect();
      const x = Math.floor((event.clientX - rect.left) * (overlay.width / rect.width));
      const y = Math.floor((event.clientY - rect.top) * (overlay.height / rect.height));
      roi = { x, y, size: ROI_DEFAULT_SIZE };
      log(`ROI обновлён: x=${roi.x}, y=${roi.y}, size=${roi.size}`);
    });

    async function startCamera() {
      setStatus('Запрашиваем доступ к камере…');
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: 'environment',
            width: { ideal: 1280 },
            height: { ideal: 720 }
          },
          audio: false
        });
        video.srcObject = stream;
        await video.play().catch(() => {});
        overlay.width = video.videoWidth || 640;
        overlay.height = video.videoHeight || 480;
        if (!roi) {
          roi = {
            x: Math.floor(overlay.width / 2),
            y: Math.floor(overlay.height / 2),
            size: ROI_DEFAULT_SIZE
          };
        }
        setStatus('Камера запущена', 'ok');
        requestAnimationFrame(loop);
      } catch (error) {
        const msg = error && error.message ? error.message : error;
        setStatus('Ошибка доступа к камере: ' + msg, 'error');
        log('Ошибка доступа к камере: ' + msg, 'error');
      }
    }

    function loop() {
      ctx.drawImage(video, 0, 0, overlay.width, overlay.height);
      if (!roi) {
        requestAnimationFrame(loop);
        return;
      }

      const { x, y, size } = roi;
      const half = size / 2;
      const rx = Math.max(0, Math.min(overlay.width - size, Math.floor(x - half)));
      const ry = Math.max(0, Math.min(overlay.height - size, Math.floor(y - half)));

      const imageData = ctx.getImageData(rx, ry, size, size);
      const analysis = detectColor(imageData);
      const detected = typeof analysis.dominant === 'string' ? analysis.dominant.toLowerCase() : 'off';
      const mapped = Object.prototype.hasOwnProperty.call(fromColorToLevel, detected) ? detected : 'off';
      const level = fromColorToLevel[mapped];

      ctx.save();
      ctx.strokeStyle = '#38bdf8';
      ctx.lineWidth = 2;
      ctx.strokeRect(rx, ry, size, size);
      ctx.restore();

      currentColorBox.style.backgroundColor = level === LightLevel.Off ? '#020617' : `rgb(${analysis.r}, ${analysis.g}, ${analysis.b})`;
      currentColorBox.textContent = level === LightLevel.Off ? '—' : '';
      currentColorEl.textContent = `${colorNames[level]} | R${analysis.r} G${analysis.g} B${analysis.b}`;

      const now = performance.now();
      if (mapped !== lastColor) {
        const duration = now - lastChange;
        const prevLevel = fromColorToLevel[lastColor];
        if (prevLevel !== undefined && duration >= minEventDurationMs) {
          recordEvent(prevLevel, duration);
        } else if (prevLevel !== undefined && duration > MIN_EVENT_DURATION_FLOOR) {
          observeDuration(duration);
          const readablePrev = colorNames[prevLevel] || lastColor;
          log(`игнор: ${readablePrev} слишком коротко (${duration.toFixed(1)}мс)`);
        }
        lastColor = mapped;
        lastChange = now;
        pendingOffDecode = mapped === 'off';
        if (pendingOffDecode) {
          setStatus('Ожидание завершения пакета…');
        } else {
          setStatus(`Фиксирован цвет: ${colorNames[level]}`);
        }
      } else if (pendingOffDecode) {
        const offDuration = now - lastChange;
        if (offDuration >= offDecodeDelayMs) {
          recordEvent(LightLevel.Off, offDuration);
          pendingOffDecode = false;
          lastColor = 'off';
          lastChange = now;
        }
      }

      if (now - lastEventTimestamp > inactivityResetMs && (lastBufferHex || lastDecodedText)) {
        resetDecoderState('Сброс после длительного отсутствия сигнала');
      }

      requestAnimationFrame(loop);
    }

    resetDecoderState();
    startCamera();
  </script>
</body>
</html>
