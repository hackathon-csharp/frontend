<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>IR LED Color Decoder with Auto Sync</title>
<style>
body{font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;margin:16px;background:#f6f7fb;color:#0b1220}
h1{font-size:20px;margin:0 0 8px}
.row{display:flex;gap:12px;align-items:flex-start;flex-wrap:wrap}
video, canvas{background:#000;border-radius:8px;max-width:100%;}
#video{display: none;}
#controls{margin-top:12px;display:flex;gap:8px;flex-wrap:wrap}
.box{padding:12px;background:#fff;border-radius:10px;box-shadow:0 2px 8px rgba(12,20,40,0.06)}
#log{height:140px;overflow:auto;background:#0b1220;color:#dff3ff;padding:8px;border-radius:8px;font-family:monospace;font-size:13px}
#decoded{height:140px;overflow:auto;background:#f0f4ff;color:#0b1220;padding:8px;border-radius:8px;font-family:monospace;font-size:13px;margin-top:8px}
button{padding:8px 12px;border-radius:8px;border:0;background:#2563eb;color:#fff;cursor:pointer}
button.secondary{background:#e6eefc;color:#0b1220}
small{color:#39424a}
#currentColorBox{width:24px;height:24px;display:inline-block;border:1px solid #ccc;margin-left:8px;vertical-align:middle;border-radius:4px}
</style>
</head>
<body>
<h1>IR LED Color Decoder with Auto Sync</h1>
<div class="row">
  <div class="box" style="flex:1;min-width:320px">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="overlay" width="640" height="480" style="position:relative;display:block;margin-top:8px"></canvas>
    <div id="controls">
      <button id="startTransmissionBtn">Начать запись</button>
      <button id="syncBtn" class="secondary">Синхронизация</button>
    </div>
    <p style="margin-top:6px"><small>Кликните на видео, чтобы выбрать область (ROI) для слежения. По умолчанию отслеживается центр.</small></p>
  </div>
  <div class="box" style="width:360px">
    <h2 style="margin-top:0">Информация</h2>
    <div id="status">—</div>

    <h3 style="margin-bottom:6px">Текущий цвет</h3>
    <div id="currentColor">—</div>
    <div id="currentColorBox"></div>

    <h3 style="margin-bottom:6px">Записанные события</h3>
    <div id="log"></div>
    <h3 style="margin-bottom:6px">Декодированное сообщение</h3>
    <div id="decoded">—</div>
  </div>
</div>



<script src="datapacklib.js"></script>
<script>
const video = document.getElementById('video');
const overlay = document.getElementById('overlay');
const ctx = overlay.getContext('2d');
const startTransmissionBtn = document.getElementById('startTransmissionBtn');
const syncBtn = document.getElementById('syncBtn');
const statusEl = document.getElementById('status');
const logEl = document.getElementById('log');
const decodedEl = document.getElementById('decoded');
const currentColorEl = document.getElementById('currentColor');
const currentColorBox = document.getElementById('currentColorBox');

const fromColorToLevel = {
  "off" : 0,
  "red": 2,
  "green": 3,
  "blue": 4,
  "white": 1,
}

const colorNames = {
  2: 'red',
  3: 'green',
  4: 'blue',
  1: 'white',
  0: 'off'
};

const defaultProtocolConfig = new datapack.ProtocolConfig();
const textDecoder = new TextDecoder();
const DECODER_DRIFT = 0.6;
const MIN_EVENT_DURATION_MS = 100;

let stream = null;
let running = false;
let roi = null;

let transmissionActive = false;
let blinkEvents = [];
let lastTransitionTime = Date.now();
let lastColor = 0;


let colorEvents = [];
let lastColorRecorded = "off";
let lastColorTime = Date.now();
let pendingDecode = false;

function msToMicros(ms) {
  return Math.max(1, Math.round(ms * 1000));
}

function attemptDecode(finalOffDurationMs = null) {
  if (!colorEvents.length) {
    return false;
  }

  const filteredEvents = colorEvents.filter(evt => evt.durationMs >= MIN_EVENT_DURATION_MS);
  if (!filteredEvents.length) {
    log('Недостаточно длинных событий для декодирования');
    return false;
  }

  const events = filteredEvents.map(evt => ({
    level: evt.level,
    durationMicros: msToMicros(evt.durationMs)
  }));

  if (typeof finalOffDurationMs === 'number' && finalOffDurationMs >= MIN_EVENT_DURATION_MS) {
    events.push({
      level: fromColorToLevel["off"],
      durationMicros: msToMicros(finalOffDurationMs)
    });
  }

  const markEvents = events.filter(evt => evt.level !== fromColorToLevel["off"]);
  if (markEvents.length < 2) {
    return false;
  }

  const preambleMarks = markEvents.filter(evt => evt.level === defaultProtocolConfig.preambleColor);
  let unitDurationMicros;
  if (preambleMarks.length) {
    const preambleDuration = Math.max(...preambleMarks.map(evt => evt.durationMicros));
    unitDurationMicros = Math.round(preambleDuration / defaultProtocolConfig.preambleMarkUnits);
  } else {
    const minMark = Math.min(...markEvents.map(evt => evt.durationMicros));
    unitDurationMicros = Math.round(minMark);
  }

  if (!Number.isFinite(unitDurationMicros) || unitDurationMicros <= 0) {
    return false;
  }

  unitDurationMicros = Math.max(200, unitDurationMicros);

  const decoderConfig = {
    unitDurationMicros,
    allowedDriftFraction: DECODER_DRIFT,
    preambleMarkUnits: defaultProtocolConfig.preambleMarkUnits,
    preambleSpaceUnits: defaultProtocolConfig.preambleSpaceUnits,
    symbolMarkUnits: defaultProtocolConfig.symbolMarkUnits,
    separatorUnits: defaultProtocolConfig.separatorUnits,
    frameGapUnits: defaultProtocolConfig.frameGapUnits,
    preambleColor: defaultProtocolConfig.preambleColor,
    maxPayloadBytes: defaultProtocolConfig.maxPayloadBytes,
    magic: defaultProtocolConfig.magic,
    ender: defaultProtocolConfig.ender,
    version: defaultProtocolConfig.version
  };

  const decodedMessages = [];
  const decoder = new datapack.Decoder((payload, length) => {
    decodedMessages.push(textDecoder.decode(payload.subarray(0, length)));
  }, null, decoderConfig);

  for (const change of events) {
    decoder.feed({ level: change.level, duration: change.durationMicros });
  }

  if (!decodedMessages.length) {
    return false;
  }

  const message = decodedMessages.join('\n');
  log('Раскодированное сообщение: ' + message);
  decodedEl.textContent = message;
  statusEl.textContent = 'Сообщение получено';
  transmissionActive = false;
  pendingDecode = false;
  colorEvents.length = 0;
  return true;
}


function log(msg){
  const time = new Date().toLocaleTimeString();
  logEl.innerHTML = `<div>[${time}] ${msg}</div>` + logEl.innerHTML;
  const lines = logEl.querySelectorAll('div');
  if(lines.length>200) lines[lines.length-1].remove();
}

overlay.addEventListener('click',(e)=>{
  const rect = overlay.getBoundingClientRect();
  const x = Math.floor((e.clientX-rect.left)*(overlay.width/rect.width));
  const y = Math.floor((e.clientY-rect.top)*(overlay.height/rect.height));
  roi = { x, y, size: 128 };
  log('ROI установлен: x=' + roi.x + ', y=' + roi.y);
});

function detectColor(imageData) {
  const data = imageData.data;
  let sumR = 0, sumG = 0, sumB = 0;
  let brightCount = 0;

  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];
    const brightness = (r + g + b) / 3;

    if (brightness < 30) {
      continue;
    }

    sumR += r;
    sumG += g;
    sumB += b;
    brightCount++;
  }

  if (!brightCount) {
    return { r: 0, g: 0, b: 0, brightness: 0, dominant: 'off' };
  }

  const avgR = sumR / brightCount;
  const avgG = sumG / brightCount;
  const avgB = sumB / brightCount;
  const brightness = (avgR + avgG + avgB) / 3;
  const total = avgR + avgG + avgB;

  if (!Number.isFinite(total) || total <= 0) {
    return { r: 0, g: 0, b: 0, brightness: 0, dominant: 'off' };
  }

  const rRatio = avgR / total;
  const gRatio = avgG / total;
  const bRatio = avgB / total;

  const ratios = [
    { name: 'red', ratio: rRatio, value: avgR },
    { name: 'green', ratio: gRatio, value: avgG },
    { name: 'blue', ratio: bRatio, value: avgB }
  ].sort((a, b) => b.ratio - a.ratio);

  const top = ratios[0];
  const second = ratios[1];
  const ratioGap = top.ratio - second.ratio;
  const channelSpread = Math.max(avgR, avgG, avgB) - Math.min(avgR, avgG, avgB);
  const whiteness = Math.max(
    Math.abs(rRatio - gRatio),
    Math.abs(rRatio - bRatio),
    Math.abs(gRatio - bRatio)
  );
  const absoluteGap = top.value - second.value;

  let dominant = 'off';

  if (brightness >= 45 && top.value >= 70) {
    if (whiteness < 0.12 && brightness >= 65 && second.value >= 80 && top.value >= 80) {
      dominant = 'white';
    } else if (ratioGap >= 0.1 && absoluteGap >= 45) {
      dominant = top.name;
    } else if (channelSpread < 25 && brightness >= 80) {
      dominant = 'white';
    }
  }

  if (dominant === 'off' && brightness >= 90 && whiteness < 0.15 && top.value >= 95 && second.value >= 90) {
    dominant = 'white';
  }

  return {
    r: Math.round(avgR),
    g: Math.round(avgG),
    b: Math.round(avgB),
    brightness,
    dominant
  };
}



async function startCamera(){
  if(running) return;
  try{
    stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:"environment", width:1280, height:720 }, audio:false });
  }catch(err){ statusEl.textContent='Ошибка доступа к камере: '+(err.message||err.name); return; }
  video.srcObject = stream;
  try{ await video.play(); }catch(e){}
  overlay.width = video.videoWidth || 640;
  overlay.height = video.videoHeight || 480;
  if(!roi) roi={x:overlay.width/2, y:overlay.height/2, size: 128};
  running=true;
  statusEl.textContent='Камера запущена';
  requestAnimationFrame(loop);
}

function loop(){
  if(!running) return;
  ctx.drawImage(video,0,0,overlay.width,overlay.height);
  const s = roi.size;
  const rx = roi.x-s/2, ry = roi.y-s/2;

  // --- Определение текущего цвета ---
  const img = ctx.getImageData(rx, ry, s, s);
  const analysis = detectColor(img);
  const colorName = (analysis.dominant || 'off');
  currentColorEl.textContent = `${colorName} (R=${analysis.r}, G=${analysis.g}, B=${analysis.b})`;
  currentColorBox.style.backgroundColor = `rgb(${analysis.r},${analysis.g},${analysis.b})`;

  ctx.save();
  ctx.strokeStyle='lime';
  ctx.lineWidth=2;
  ctx.strokeRect(rx,ry,s,s);
  ctx.restore();





  // --- Если идёт запись, фиксируем смену цвета ---
  if (transmissionActive) {
    const now = Date.now();
    if (colorEvents.length && now - lastColorTime > 30000){
      transmissionActive = false;
      pendingDecode = false;
      log("Не удалось распознать пакет");
      colorEvents.length = 0;
      statusEl.textContent = 'Пакет не распознан';
      decodedEl.textContent = '—';
    } else {
      const colorLower = colorName.toLowerCase();
      if (colorLower !== lastColorRecorded) {
        const duration = now - lastColorTime;
        const level = fromColorToLevel[lastColorRecorded];
        if (level !== undefined) {
          if (duration >= MIN_EVENT_DURATION_MS) {
            colorEvents.push({ level, durationMs: duration });
            log(`event: ${lastColorRecorded} level=${level}, duration=${duration.toFixed(1)}мс`);
          } else {
            log(`игнор: ${lastColorRecorded} слишком коротко (${duration.toFixed(1)}мс)`);
          }
        }

        lastColorRecorded = colorLower;
        lastColorTime = now;
        pendingDecode = colorLower === 'off';
        if (colorLower === 'off') {
          statusEl.textContent = 'Ожидание завершения пакета';
        } else {
          statusEl.textContent = 'Фиксирован цвет: ' + colorLower;
        }
      }

      if (pendingDecode) {
        const offDuration = Date.now() - lastColorTime;
        if (offDuration > MIN_EVENT_DURATION_MS * 2) {
          const decoded = attemptDecode(offDuration);
          if (!decoded) {
            pendingDecode = false;
          }
        }
      }
    }
  }


  requestAnimationFrame(loop);
}



startTransmissionBtn.addEventListener('click',()=>{
  transmissionActive=true;
  blinkEvents=[];
  lastTransitionTime=Date.now();
  lastColor=0;
  colorEvents.length = 0;
  lastColorRecorded = 'off';
  lastColorTime = Date.now();
  pendingDecode = false;
  decodedEl.textContent = '—';
  statusEl.textContent = 'Запись активна';
  log('Начата запись сигналов');
});




// // --- СИНХРОНИЗАЦИЯ ---
// syncBtn.addEventListener('click', async () => {
//   log('Начата синхронизация...');
  
//   const states = ['Выкл', 'Белый', 'Выкл','Красный', 'Выкл','Синий', 'Выкл','Зелёный'];
//   const colorSamples = {};
//   const thresholdMargin = 100; 
//   let prevColor = null;
//   let stateIndex = 0;
//   const roiSamples = 1; 

//   function averageColor(samples) {
//     const avg = samples.reduce((acc, val) => {
//       acc.r += val.r; acc.g += val.g; acc.b += val.b;
//       return acc;
//     }, { r: 0, g: 0, b: 0 });
//     avg.r = Math.round(avg.r / samples.length);
//     avg.g = Math.round(avg.g / samples.length);
//     avg.b = Math.round(avg.b / samples.length);
//     return avg;
//   }

//   function colorDelta(c1, c2) {
//     return Math.abs(c1.r - c2.r) + Math.abs(c1.g - c2.g) + Math.abs(c1.b - c2.b);
//   }

//   function brightness(rgb) {
//     return rgb.r + rgb.g + rgb.b;
//   }

//   while (stateIndex < states.length) {
//     const samples = [];
//     for (let i = 0; i < roiSamples; i++) {
//       const img = ctx.getImageData(roi.x - roi.size / 2, roi.y - roi.size / 2, roi.size, roi.size);
//       samples.push(detectColor(img));
//       await new Promise(r => setTimeout(r, 1));
//     }
//     const rgb = averageColor(samples);
//     const bright = brightness(rgb);

//     if (!prevColor) {
//       prevColor = rgb;
//       colorSamples[states[stateIndex]] = { ...rgb };
//       log(`Состояние ${states[stateIndex]} захвачено: R=${rgb.r}, G=${rgb.g}, B=${rgb.b}`);
//       stateIndex++;
//     } else {
//       const delta = colorDelta(rgb, prevColor);
//       if (delta > thresholdMargin) {
//         colorSamples[states[stateIndex]] = { ...rgb };
//         log(`Состояние ${states[stateIndex]} захвачено: R=${rgb.r}, G=${rgb.g}, B=${rgb.b}`);
//         stateIndex++;
//       }
//       prevColor = rgb;
//     }
//     await new Promise(r => setTimeout(r, 50));
//   }

//   log('Синхронизация завершена. Пороговые значения цветов:');
//   for (const state in colorSamples) {
//     const rgb = colorSamples[state];
//     log(`${state}: R=${rgb.r}, G=${rgb.g}, B=${rgb.b}`);
//   }
// });

startCamera();
</script>
</body>
</html>
