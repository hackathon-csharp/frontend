<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>IR LED Blink Detector</title>
<style>
body{font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;margin:16px;background:#f6f7fb;color:#0b1220}
h1{font-size:20px;margin:0 0 8px}
.row{display:flex;gap:12px;align-items:flex-start;flex-wrap:wrap}
video, canvas{background:#000;border-radius:8px;max-width:100%;}
#video{display: none;}
#controls{margin-top:12px;display:flex;gap:8px;flex-wrap:wrap}
label{font-size:13px}
.box{padding:12px;background:#fff;border-radius:10px;box-shadow:0 2px 8px rgba(12,20,40,0.06)}
input[type=range]{width:180px}
#log{height:140px;overflow:auto;background:#0b1220;color:#dff3ff;padding:8px;border-radius:8px;font-family:monospace;font-size:13px}
button{padding:8px 12px;border-radius:8px;border:0;background:#2563eb;color:#fff;cursor:pointer}
button.secondary{background:#e6eefc;color:#0b1220}
small{color:#39424a}
</style>
</head>
<body>
<h1>IR LED Blink Detector (веб)</h1>
<div class="row">
  <div class="box" style="flex:1;min-width:320px">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="overlay" width="640" height="480" style="position:relative;display:block;margin-top:8px"></canvas>
    <div id="controls" style="margin-top:12px">
      <button id="startTransmissionBtn">Начать передачу</button>
      <button id="syncBtn" class="secondary">Синхронизация</button>
    </div>
    <p style="margin-top:6px"><small>Кликните на видео, чтобы выбрать область (ROI) для слежения. По умолчанию отслеживается центр.</small></p>
  </div>
  <div class="box" style="width:360px">
    <h2 style="margin-top:0">Информация</h2>
    <p style="margin:6px 0">Датчик считает яркость в выбранной области и фиксирует состояния: светодиод горит или не горит.</p>
    <h3 style="margin-bottom:6px">Состояния</h3>
    <div id="status">—</div>
    <h3 style="margin-bottom:6px">Записанные события</h3>
    <div id="log"></div>
  </div>
</div>

<script>
const video = document.getElementById('video');
const overlay = document.getElementById('overlay');
const ctx = overlay.getContext('2d');
const startTransmissionBtn = document.getElementById('startTransmissionBtn');
const syncBtn = document.getElementById('syncBtn');
const statusEl = document.getElementById('status');
const logEl = document.getElementById('log');

let stream = null;
let running = false;
let rafId = null;
let smoothing = 0.15;
let smoothVal = 0;
let roi = null;

let transmissionActive = false;
let blinkEvents = []; 
let lastTransitionTime = Date.now();
let isOn = false;

// Для синхронизации
let minBrightness = Infinity;
let maxBrightness = -Infinity;
let calibratedThreshold = null;
let syncing = false;

async function startCamera() {
  if (running) return;

  const constraints = { video:{ facingMode:{ideal:"environment"}, width:{ideal:1280}, height:{ideal:720} }, audio:false };
  try {
    stream = await navigator.mediaDevices.getUserMedia(constraints);
  } catch {
    try { stream = await navigator.mediaDevices.getUserMedia({video:true,audio:false}); }
    catch(err) { statusEl.textContent = 'Ошибка доступа к камере: ' + (err.message||err.name); return; }
  }

  video.srcObject = stream;
  video.muted = true; video.playsInline = true; video.autoplay = true;
  try { await video.play(); } catch(e){}

  overlay.width = video.videoWidth || 640;
  overlay.height = video.videoHeight || 480;
  if (!roi) roi = { x: Math.floor(overlay.width/2), y: Math.floor(overlay.height/2), size: 64 };

  running = true;
  statusEl.textContent = 'Камера запущена';
  loop();
}

function log(msg){
  const time = new Date().toLocaleTimeString();
  logEl.innerHTML = `<div>[${time}] ${msg}</div>` + logEl.innerHTML;
  const lines = logEl.querySelectorAll('div');
  if(lines.length>200) lines[lines.length-1].remove();
}

overlay.addEventListener('click',(e)=>{
  const rect = overlay.getBoundingClientRect();
  const x = Math.floor((e.clientX-rect.left)*(overlay.width/rect.width));
  const y = Math.floor((e.clientY-rect.top)*(overlay.height/rect.height));
  roi = { x, y, size:64 };
  log('ROI установлен: x=' + roi.x + ', y=' + roi.y);
});

function detectBrightness(imageData){
  const data = imageData.data;
  let sum = 0;
  const px = imageData.width * imageData.height;
  for(let i=0;i<data.length;i+=4) sum+=data[i];
  return sum/px;
}

function loop(){
  if(!running) return;

  function frame(){
    rafId = requestAnimationFrame(frame);

    ctx.drawImage(video,0,0,overlay.width,overlay.height);

    const s = roi ? roi.size : 64;
    const rx = (roi ? roi.x : overlay.width/2) - s/2;
    const ry = (roi ? roi.y : overlay.height/2) - s/2;

    ctx.strokeStyle='lime'; ctx.lineWidth=2;
    ctx.strokeRect(rx,ry,s,s);

    try{
      const img = ctx.getImageData(rx,ry,s,s);
      const brightness = detectBrightness(img);
      smoothVal = smoothVal*(1-smoothing) + brightness*smoothing;

      ctx.fillStyle='rgba(255,255,255,0.08)';
      ctx.fillRect(6,overlay.height-22,Math.min(overlay.width-12,(smoothVal/255)*(overlay.width-12)),16);
      ctx.fillStyle='white'; ctx.font='48px monospace';
      ctx.fillText('B: '+Math.round(smoothVal),8,overlay.height-8);

      if(!transmissionActive) return;

      const thr = calibratedThreshold !== null ? calibratedThreshold : 160;
      const high = smoothVal >= thr;

      if(high !== isOn){
        const nowTime = Date.now();
        const durationSec = (nowTime - lastTransitionTime)/1000;

        blinkEvents.push({
          state: isOn ? 'горит' : 'не горит',
          duration: durationSec
        });

        lastTransitionTime = nowTime;
        isOn = high;

        log(`${isOn ? 'Светодиод горит' : 'Светодиод не горит'}, длительность предыдущего состояния: ${durationSec.toFixed(2)} сек`);
      }
    } catch(e){ console.warn('getImageData error',e); }
  }

  frame();
}

// --- СИНХРОНИЗАЦИЯ ---
function startSync() {
  if (syncing) return;
  syncing = true;
  log('Синхронизация: измеряем минимум (светодиод выключен, 5 сек)...');

  minBrightness = Infinity;
  maxBrightness = -Infinity;

  let phase = 0;
  let phaseTime = Date.now();

  function syncStep() {
    const now = Date.now();
    const elapsed = (now - phaseTime) / 1000;

    if (phase === 0) {
      if (smoothVal < minBrightness) minBrightness = smoothVal;
      if (elapsed >= 5) {
        phase = 1;
        phaseTime = now;
        log('Теперь включите светодиод. Измеряем максимум (5 сек)...');
      }
    } else if (phase === 1) {
      if (smoothVal > maxBrightness) maxBrightness = smoothVal;
      if (elapsed >= 5) {
        calibratedThreshold = (minBrightness + maxBrightness) / 2;
        log(`Синхронизация завершена. minB=${minBrightness.toFixed(1)}, maxB=${maxBrightness.toFixed(1)}, порог=${calibratedThreshold.toFixed(1)}`);
        syncing = false;
        return;
      }
    }
    requestAnimationFrame(syncStep);
  }
  syncStep();
}

// Запускаем камеру сразу при загрузке страницы
startCamera();

// Кнопки
startTransmissionBtn.addEventListener('click',()=>{
  transmissionActive = true;
  log('Начата передача');
  lastTransitionTime = Date.now();
});

syncBtn.addEventListener('click', startSync);

// останавливаем камеру при закрытии страницы
window.addEventListener('beforeunload',()=>{ 
  if(stream) { stream.getTracks().forEach(t=>t.stop()); } 
});
</script>
</body>
</html>
